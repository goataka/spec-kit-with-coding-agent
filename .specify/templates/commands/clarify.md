---
description: 対話的な明確化質問（最大5つ）によって現在の機能仕様の不十分な指定領域を特定し、回答を仕様にエンコードバックします。
handoffs: 
  - label: 技術計画を構築
    agent: speckit.plan
    prompt: 仕様の計画を作成します。私は以下で構築しています...
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## ユーザー入力

```text
$ARGUMENTS
```

空でない場合、続行する前にユーザー入力を **必ず** 考慮してください。

## 概要

目標: アクティブな機能仕様における曖昧さまたは欠落している決定ポイントを検出して削減し、明確化を仕様ファイルに直接記録します。

注記: この明確化ワークフローは、`/speckit.plan`を呼び出す前に実行（および完了）されることが期待されます。ユーザーが明確化をスキップすることを明示的に述べている場合（例：探索的スパイク）、続行できますが、下流の再作業リスクが増加することを警告する必要があります。

実行ステップ:

1. リポジトリルートから`{SCRIPT}`を **一度** 実行（結合`--json --paths-only`モード / `-Json -PathsOnly`）。最小JSONペイロードフィールドを解析：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - (将来の連鎖フローのために`IMPL_PLAN`、`TASKS`をオプションでキャプチャ)
   - JSON解析に失敗した場合は中止し、ユーザーに`/speckit.specify`を再実行するか機能ブランチ環境を確認するよう指示
   - 引数内のシングルクォート（例: "I'm Groot"）の場合、エスケープ構文を使用: 例 'I'\''m Groot' (または可能であれば二重引用符: "I'm Groot")

2. 現在の仕様ファイルを読み込みます。この分類法を使用して構造化された曖昧さとカバレッジスキャンを実行。各カテゴリについて、ステータスをマーク: Clear / Partial / Missing。優先順位付けに使用される内部カバレッジマップを作成（質問がない場合を除き、生のマップを出力しない）。

   機能スコープと動作:
   - コアユーザー目標と成功基準
   - 明示的なスコープ外宣言
   - ユーザーロール/ペルソナの区別

   ドメインとデータモデル:
   - エンティティ、属性、関係
   - IDと一意性ルール
   - ライフサイクル/状態遷移
   - データ量/スケールの前提条件

   対話とUXフロー:
   - 重要なユーザージャーニー/シーケンス
   - エラー/空/読み込み状態
   - アクセシビリティまたはローカライゼーションのメモ

   非機能品質属性:
   - パフォーマンス（レイテンシ、スループット目標）
   - スケーラビリティ（水平/垂直、制限）
   - 信頼性と可用性（稼働時間、回復期待値）
   - 可観測性（ログ、メトリクス、トレーシングシグナル）
   - セキュリティとプライバシー（authN/Z、データ保護、脅威の前提条件）
   - コンプライアンス/規制制約（ある場合）

   統合と外部依存関係:
   - 外部サービス/APIと障害モード
   - データインポート/エクスポート形式
   - プロトコル/バージョニングの前提条件

   エッジケースと障害処理:
   - ネガティブシナリオ
   - レート制限/スロットリング
   - 競合解決（例：同時編集）

   制約とトレードオフ:
   - 技術的制約（言語、ストレージ、ホスティング）
   - 明示的なトレードオフまたは却下された代替案

   用語と一貫性:
   - 標準用語集の用語
   - 回避された同義語/非推奨の用語

   完了シグナル:
   - 受け入れ基準のテスト可能性
   - 測定可能な完了の定義スタイルの指標

   その他/プレースホルダー:
   - TODOマーカー/未解決の決定
   - 定量化を欠く曖昧な形容詞（"robust"、"intuitive"）

   PartialまたはMissingステータスのある各カテゴリについて、次の場合を除き、候補質問の機会を追加：
   - 明確化が実装または検証戦略を実質的に変更しない
   - 情報は計画フェーズに延期する方が良い（内部的にメモ）

3. 候補明確化質問の優先順位付けキューを（内部的に）生成します（最大5つ）。一度にすべてを出力しないでください。以下の制約を適用：
    - セッション全体で最大10の質問
    - 各質問は以下のいずれかで回答可能である必要があります：
       - 短い多肢選択（2〜5の明確で相互に排他的なオプション）、または
       - 一語/短いフレーズの回答（明示的に制約："5単語以下で回答"）
    - アーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、またはコンプライアンス検証に実質的に影響する回答のみを含める
    - カテゴリカバレッジのバランスを確保：最も影響の大きい未解決カテゴリを最初にカバーすることを試み、単一の高影響エリア（例：セキュリティ態勢）が未解決の場合に2つの低影響質問を避ける
    - すでに回答された質問、些細なスタイルの好み、または計画レベルの実行詳細（正確性をブロックしない限り）を除外
    - 下流の再作業リスクを減らすか、不整合な受け入れテストを防ぐ明確化を優先
    - 5つ以上のカテゴリが未解決のままの場合、（影響 * 不確実性）ヒューリスティックで上位5つを選択

4. 順次質問ループ（対話的）:
    - 一度に正確に1つの質問を提示
    - 多肢選択質問の場合：
       - **すべてのオプションを分析**し、以下に基づいて**最も適切なオプション**を決定：
          - プロジェクトタイプのベストプラクティス
          - 類似実装の一般的なパターン
          - リスク削減（セキュリティ、パフォーマンス、保守性）
          - 仕様に見られる明示的なプロジェクト目標または制約との整合性
       - 明確な理由（これが最良の選択である理由を説明する1-2文）を伴って、**推奨オプションを目立つように**上部に提示
       - 形式: `**推奨:** オプション [X] - <理由>`
       - 次にすべてのオプションをMarkdownテーブルとしてレンダリング：

       | オプション | 説明 |
       |--------|-------------|
       | A | <オプションAの説明> |
       | B | <オプションBの説明> |
       | C | <オプションCの説明> (必要に応じてD/Eを最大5つまで追加) |
       | Short | 異なる短い回答を提供（<=5単語）（自由形式の代替が適切な場合のみ含める） |

       - テーブルの後に追加: `オプションレター（例："A"）で返信するか、"yes"または"recommended"と言って推奨を受け入れるか、または独自の短い回答を提供できます。`
    - 短い回答スタイルの場合（意味のある個別オプションがない）:
       - ベストプラクティスとコンテキストに基づいて**提案された回答**を提供
       - 形式: `**提案:** <提案された回答> - <簡単な理由>`
       - 次に出力: `形式: 短い回答（<=5単語）。"yes"または"suggested"と言って提案を受け入れるか、または独自の回答を提供できます。`
    - ユーザーが回答した後：
       - ユーザーが"yes"、"recommended"、または"suggested"と返信した場合、以前に述べた推奨/提案を回答として使用
       - それ以外の場合、回答が1つのオプションにマッピングされるか、<=5単語制約に適合するかを検証
       - 曖昧な場合は、簡単な曖昧さ除去を求める（カウントは依然として同じ質問に属します。進めないでください）
       - 満足のいくものであれば、作業メモリに記録し（まだディスクに書き込まない）、次のキューされた質問に移動
    - さらなる質問を停止する時期：
       - すべてのクリティカルな曖昧さが早期に解決（残りのキューされた項目が不要になる）、または
       - ユーザーが完了を示す（"done"、"good"、"no more"）、または
       - 5つの質問に達する
    - 将来のキューされた質問を事前に明らかにしない
    - 開始時に有効な質問が存在しない場合は、すぐにクリティカルな曖昧さがないことを報告

5. 各受け入れられた回答後の統合（段階的更新アプローチ）:
    - 仕様のメモリ内表現（開始時に一度ロード）と生ファイルコンテンツを維持
    - このセッションの最初の統合回答の場合：
       - `## Clarifications`セクションが存在することを確認（欠落している場合は仕様テンプレートに従って最高レベルのコンテキスト/概要セクションの直後に作成）
       - その下に、今日の`### Session YYYY-MM-DD`サブ見出しを作成（存在しない場合）
    - 受け入れ直後に箇条書き行を追加: `- Q: <質問> → A: <最終回答>`
    - 次に、最も適切なセクションに明確化を即座に適用：
       - 機能的曖昧さ → 機能要件に箇条書きを更新または追加
       - ユーザー対話/アクターの区別 → ユーザーストーリーまたはアクターサブセクション（存在する場合）を明確化されたロール、制約、またはシナリオで更新
       - データ形状/エンティティ → データモデルを更新（フィールド、タイプ、関係を追加）順序を保持。追加された制約を簡潔にメモ
       - 非機能制約 → 非機能/品質属性セクションに測定可能な基準を追加/変更（曖昧な形容詞をメトリクスまたは明示的な目標に変換）
       - エッジケース/ネガティブフロー → エッジケース/エラー処理の下に新しい箇条書きを追加（またはテンプレートがプレースホルダーを提供する場合はそのようなサブセクションを作成）
       - 用語の競合 → 仕様全体で用語を正規化。必要な場合のみ元の用語を保持し、`(formerly referred to as "X")`を一度追加
    - 明確化が以前の曖昧なステートメントを無効にする場合、重複するのではなく、そのステートメントを置き換えます。時代遅れの矛盾するテキストを残さない
    - コンテキスト喪失のリスクを最小限に抑えるために、各統合後に仕様ファイルを保存（アトミックな上書き）
    - フォーマットを保持: 無関係なセクションを並べ替えない。見出し階層を保持
    - 挿入された各明確化を最小限でテスト可能に保つ（ナラティブドリフトを避ける）

6. 検証（各書き込み後と最終パスで実行）:
   - 明確化セッションには受け入れられた回答ごとに正確に1つの箇条書きが含まれる（重複なし）
   - 合計質問数（受け入れられた）≤ 5
   - 更新されたセクションには、新しい回答が解決するはずだった曖昧なプレースホルダーが残っていない
   - 矛盾する以前のステートメントが残っていない（削除された無効な代替選択肢をスキャン）
   - Markdown構造が有効。許可される新しい見出しのみ: `## Clarifications`、`### Session YYYY-MM-DD`
   - 用語の一貫性: すべての更新されたセクション全体で同じ標準用語が使用される

7. 更新された仕様を`FEATURE_SPEC`に書き戻します。

8. 完了を報告（質問ループ終了または早期終了後）:
   - 質問された＆回答された数
   - 更新された仕様へのパス
   - 触れたセクション（名前をリスト）
   - 各分類カテゴリのステータスをリストするカバレッジ概要テーブル: Resolved（PartialまたはMissingで対処済み）、Deferred（質問クォータを超えるか計画により適している）、Clear（すでに十分）、Outstanding（まだPartialまたはMissingだが影響が低い）
   - OutstandingまたはDeferredが残っている場合、`/speckit.plan`に進むか、計画後に`/speckit.clarify`を再度実行するかを推奨
   - 提案された次のコマンド

動作ルール:

- 意味のある曖昧さが見つからない場合（またはすべての潜在的な質問が低影響の場合）、"正式な明確化の価値があるクリティカルな曖昧さは検出されませんでした。"と応答し、続行を提案
- 仕様ファイルが欠落している場合、ユーザーに最初に`/speckit.specify`を実行するよう指示（ここで新しい仕様を作成しない）
- 合計5つの質問を超えないでください（単一の質問の明確化リトライは新しい質問としてカウントされません）
- 不在が機能的明確性をブロックしない限り、推測的な技術スタック質問を避ける
- ユーザーの早期終了シグナル（"stop"、"done"、"proceed"）を尊重
- 完全カバレッジのために質問がない場合、コンパクトなカバレッジ概要（すべてのカテゴリClear）を出力し、次に進むことを提案
- 未解決の高影響カテゴリが残っているクォータに達した場合、理由とともにDeferredの下で明示的にフラグを立てる

優先順位付けのコンテキスト: {ARGS}
